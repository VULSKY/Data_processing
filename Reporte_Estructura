import pandas as pd
import os
import warnings

# Ignorar advertencias de estilos de Excel para mantener la consola limpia
warnings.filterwarnings('ignore', category=UserWarning, module='openpyxl')

def encontrar_fila_encabezado(df, palabras_clave):
    """
    Busca en las primeras 10 filas si encuentra alguna de las palabras clave
    para determinar dónde empieza realmente la tabla.
    """
    for i in range(min(10, len(df))):
        fila = df.iloc[i].astype(str).str.lower().tolist()
        # Verificamos si al menos una palabra clave está en esta fila
        if any(clave.lower() in valor for valor in fila for clave in palabras_clave):
            return i
    return 0

def clasificar_dataframe(columns):
    """
    Determina a qué categoría pertenece la hoja basándose en sus columnas (Lógica General).
    """
    cols = [str(c).lower() for c in columns]
    
    # Lógica de identificación basada en tu estructura JSON
    if 'prestación' in cols and 'unidad organizativa' in cols and 'status del episodio' in cols:
        return "Citas_SAP"
    elif 'no. orden' in cols and 'cups' in cols and 'institución' in cols:
        return "Ordenes_SAP"
    elif 'cod signo vital' in cols and 'valor param. vital|estruct.' in cols:
        return "Signos_Vitales"
    elif 'codigo_cita' in cols and 'nivel_usr' in cols:
        return "Citas_NEPS"
    elif 'agendacita_id' in cols and 'oportunidad' in cols:
        return "Reporte_001_Agendamiento"
    elif 'numero_autorizacion' in cols and 'valorunitario' in cols:
        return "Reporte_007_Facturacion"
    else:
        # Se deja como 'Otros_Datos' si no encaja en ningun patron conocido
        return "Otros_Datos"

def procesar_archivos():
    print("--- CONSOLIDADOR DE ARCHIVOS DE SALUD (SAP/NEPS) ---")
    ruta_carpeta = input("Por favor, ingresa la ruta de la carpeta donde están los archivos Excel: ").strip()
    
    if not os.path.exists(ruta_carpeta):
        print("La ruta no existe. Por favor verifica.")
        return

    # Diccionario para almacenar los dataframes agrupados (¡Actualizado con categorías separadas!)
    grupos_datos = {
        "Citas_SAP": [],
        "Ordenes_SAP": [],
        "Signos_Vitales": [],
        "Citas_NEPS": [],
        "Reporte_001_Agendamiento": [],
        "Reporte_007_Facturacion": [],
        # Categorías separadas para el archivo de Ordenamientos NEPS
        "Ordenamientos_NEPS": [],      
        "Costos_NEPS": [],             # Costos
        "Centro_Costos_NEPS": [],      # Centros de Costos
        "Otros_Datos": []              
    }

    archivos = [f for f in os.listdir(ruta_carpeta) if f.endswith(('.xlsx', '.xls'))]
    print(f"Se encontraron {len(archivos)} archivos. Procesando...")

    for archivo in archivos:
        ruta_completa = os.path.join(ruta_carpeta, archivo)
        try:
            # Leer todas las hojas del archivo
            xls = pd.read_excel(ruta_completa, sheet_name=None, header=None)
            archivo_lower = archivo.lower()
            
            for nombre_hoja, df_raw in xls.items():
                if df_raw.empty:
                    continue

                # 1. Intentar encontrar el encabezado correcto
                keywords = ['prestación', 'no. orden', 'cod signo vital', 'codigo_cita', 'identificacion', 'cups', 'valorunitario']
                idx_header = encontrar_fila_encabezado(df_raw, keywords)
                
                # 2. Re-leer o ajustar el dataframe con el encabezado correcto
                if idx_header > 0:
                    df = pd.read_excel(ruta_completa, sheet_name=nombre_hoja, header=idx_header)
                else:
                    df = pd.read_excel(ruta_completa, sheet_name=nombre_hoja)

                # 3. Clasificación y Lógica Específica
                categoria = "Otros_Datos" # Default
                nombre_hoja_lower = nombre_hoja.lower()
                
                # --- LÓGICA ESPECÍFICA PARA "Ordenamientos NEPS 202510_LIMPIO" ---
                if 'ordenamientos neps' in archivo_lower:
                    if 'detalle consolidado' in nombre_hoja_lower:
                        categoria = "Ordenamientos_NEPS"
                    # Priorizamos "centro de costos" ya que es más específico que solo "costos"
                    elif 'centro de costo' in nombre_hoja_lower: 
                        categoria = "Centro_Costos_NEPS"
                    elif 'costos' in nombre_hoja_lower:
                        categoria = "Costos_NEPS"
                    else:
                        # Se ignora cualquier otra hoja en este archivo específico
                        print(f"  -> {archivo} [{nombre_hoja}] IGNORADA por regla específica de Ordenamientos NEPS.")
                        continue # Salta el resto del loop para esta hoja
                
                # --- LÓGICA GENERAL (Clasificación por Columnas) ---
                else:
                    categoria = clasificar_dataframe(df.columns)
                
                # 4. Añadir columna de trazabilidad
                df['Origen_Archivo'] = archivo
                df['Origen_Hoja'] = nombre_hoja
                
                # 5. Guardar en el grupo correspondiente
                # Aseguramos que todas las columnas sean tipo string para evitar errores de concatenación
                df = df.astype(str)
                grupos_datos[categoria].append(df)
                
                print(f"  -> {archivo} [{nombre_hoja}] clasificado como: {categoria}")

        except Exception as e:
            print(f"  X Error procesando {archivo}: {e}")

    # Consolidar y Exportar
    print("\nGenerando archivo consolidado...")
    ruta_salida = os.path.join(ruta_carpeta, "Consolidado_Maestro_Salud.xlsx")
    
    with pd.ExcelWriter(ruta_salida, engine='xlsxwriter') as writer:
        guardado = False
        for categoria, lista_dfs in grupos_datos.items():
            if lista_dfs:
                print(f"  Uniendo {len(lista_dfs)} tabla(s) para: {categoria}")
                df_final = pd.concat(lista_dfs, ignore_index=True)
                
                # Limpieza básica de columnas vacías generadas por la lectura
                df_final = df_final.dropna(how='all', axis=1)
                
                # Guardar en una hoja específica
                try:
                    df_final.to_excel(writer, sheet_name=categoria, index=False)
                    guardado = True
                except Exception as e:
                    print(f"Advertencia: No se pudo guardar la hoja {categoria} debido a un error ({e}).")
        
    if guardado:
        print(f"\n¡ÉXITO! Archivo guardado en: {ruta_salida}")
        print("El archivo maestro está listo para Power BI con Costos y Centros de Costos separados.")
    else:
        print("\nNo se encontraron datos válidos para consolidar.")

if __name__ == "__main__":
    procesar_archivos()